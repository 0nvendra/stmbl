COMP(adc);

HAL_PIN(sin) = 0.0;
HAL_PIN(cos) = 0.0;
HAL_PIN(sin3) = 0.0;
HAL_PIN(cos3) = 0.0;

HAL_PIN(res_en) = 0.0;

HAL_PIN(sin_gain) = 1.0;
HAL_PIN(cos_gain) = 1.0;

HAL_PIN(sin_offset) = 0.0;
HAL_PIN(cos_offset) = 0.0;

RT(
  uint32_t si[PID_WAVES];
  uint32_t co[PID_WAVES];
  uint32_t sc[PID_WAVES];

  float s_o = PIN(sin_offset);
  float c_o = PIN(cos_offset);
  float s_g = PIN(sin_gain);
  float c_g = PIN(cos_gain);

  float s = 0.0;
  float c = 0.0;

  for(int i = 0; i < PID_WAVES; i++){
    sc[i] = 0.0;
    for(int j = 0; j < ADC_ANZ; j++){
		//ADC dual mode puts both channels in one word, right aligned.
		//ugly hack. this works as long as the maximum sum of each channel fits in 16 bits. (up to 16 samples)
      sc[i] += ADC_DMA_Buffer[i * ADC_ANZ + j];
    }
  }

  //seperate channels
  for(int i = 0; i < PID_WAVES; i++){
    si[i] = 0.0;
    co[i] = 0.0;

    si[i] = sc[i] & 0x0000ffff;
    co[i] = sc[i] >> 16;
  }

  s = s_g * (si[3] + s_o);
  c = c_g * (co[3] + c_o);

  PIN(sin3) = s;
  PIN(cos3) = c;

  if(PIN(res_en) > 0.0){
    s = s_g * (0.5 * si[3] - 0.25 * si[2] + 0.125 * si[1] - 0.125 * si[0] + 0.25 * s_o);
    c = c_g * (0.5 * co[3] - 0.25 * co[2] + 0.125 * co[1] - 0.125 * co[0] + 0.25 * c_o);
  }
  else{
    s = s_g * (0.5 * si[3] + 0.25 * si[2] + 0.125 * si[1] + 0.125 * si[0] + s_o);
    c = c_g * (0.5 * co[3] + 0.25 * co[2] + 0.125 * co[1] + 0.125 * co[0] + c_o);
  }

  PIN(sin) = s;
  PIN(cos) = c;


);

ENDCOMP;
