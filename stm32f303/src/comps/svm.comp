HAL_COMP(svm);

//U V W inputs
HAL_PIN(u) = 0;
HAL_PIN(v) = 0;
HAL_PIN(w) = 0;

//dclink input
HAL_PIN(udc) = 0;

//U V W outputs
HAL_PIN(su);
HAL_PIN(sv);
HAL_PIN(sw);

//commutation mode
HAL_PIN(cmode) = 0.0;

//modulation mode
HAL_PIN(mode) = 2.0;

//half bridge enable out
HAL_PIN(enu) = 1.0;
HAL_PIN(env) = 1.0;
HAL_PIN(enw) = 1.0;

RT(
   float offset = 0;
   float udc = PIN(udc);
   
   float u = PIN(u);
   float v = PIN(v);
   float w = PIN(w);
   
   switch((int)PIN(mode)){
      default:
      case 0: // sine modulation
         offset = (u + v + w) / 3.0 - udc / 2.0;
         break;
      
      case 1: // space vector modulation
         offset = (MIN3(u, v, w) + MAX3(u, v, w)) / 2.0 - udc / 2.0;
         break;
         
      case 2: // flat bottom space vector modulation
         offset = MIN3(u, v, w);
         break;
         
      case 3: // flat top space vector modulation
         offset = MAX3(u, v, w) - udc;
         break;
   }
   
   PIN(enu) = 1.0;
   PIN(env) = 1.0;
   PIN(enw) = 1.0;
   
   switch((int)PIN(cmode)){
      case 1: // block 
         if(u > v && u < w){
            PIN(enu) = 0.0;
         }
         if(v > u && v < w){
            PIN(env) = 0.0;
         }
         if(w > u && w < v){
            PIN(enw) = 0.0;
         }
         break;
         
      default: // sine
         break;
   }
   
   PIN(su) = u - offset;
   PIN(sv) = v - offset;
   PIN(sw) = w - offset;
);

ENDCOMP;
